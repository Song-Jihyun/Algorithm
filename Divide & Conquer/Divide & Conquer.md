# Divide & Conquer / 분할 정복
: 주어진 문제를 둘 이상의 부분으로 나눈 뒤 각 문제에 대한 답을 재귀 호출을 이용해 계산하고, 각 부분 문제의 답으로부터 전체 문제의 답을 계산


## 분할 정복의 예시
예시 1: 숫자 N이 주어졌을 때 1~N까지 합을 구하는 함수
<pre>
<code>
// 분할 과정: (1+2+...+(N/2)) + (((N/2)+1)+((N/2)+2)+...+N)
// 뒤의 식을 sum으로 구할 수 있는 형태로 변환: (N/2)*(N/2)+(1+2+...+(N/2)
// 최종 식: sum(N) == 2*sum(N/2) + (N/2)*(N/2)
// *N이 짝수일때만 가능, N이 홀수일때는 sum(N-1)+N을 호출해서 N을 짝수로 만들어줘야함.

int sum(int N){
  if(N == 1) return 1; <strong>// base case</strong>
  
  if(N%2 == 1) return sum(N-1)+N;
  return 2*sum(N/2)+(N/2)*(N/2); <strong>// divide, merge</strong>
}
</code>
</pre>


## Divide, Merge, Base case
분할정복은 총 세 단계로 나뉜다.
<ul>
  <li>Divide: 작업을 분할하는 과정</li>
  <li>Merge: 분할 처리되었던 두 작업을 합치는 과정</li>
  <li>Base Case: 재귀 호출을 통해 이루어지기 때문에 더이상 작업을 조각낼 수 없을 때 상수값을 return하는 단계</li>
</ul>
이 세 과정은 다른 일반적인 재귀함수에서도 찾아볼 수 있지만 Divide에서 큰 차이점을 보인다.<br>
일반적인 재귀함수는 [한 단계의 작업]+[나머지 작업]으로 나뉘지만 분할정복은 [절반의 작업] + [나머지 절반의 작업]으로 나뉜다.


## 시간복잡도
문제에 따라 다르지만 대체로 재귀함수의 깊이는 logN이 나온다.
<pre>
<code>
root : 1개 [sum(1, 8)]
1단계 : 2개 [2*sum(1, 4) + M]
2단계 : 4개 [(2*sum(1, 2) + M) * 2]
3단계 : 8개 [((2*sum(1, 1) + M) * 2) * 2]

-> n단계를 거쳤을 때 나오는 결과의 수 : 2<sup>n</sup>
-> N개의 결과를 확인하는데 필요한 단계의 수 : log<sub>2</sub>N
</code>
</pre>
